# Opening

Return is a Manifest V3 browser extension that replaces the default new-tab page with a compact operating board for active work. The system is built around fast orientation: opening a tab should immediately reveal campaign intent, active mission text, and executable projects without drag interactions, modal detours, or hidden layout state. The architecture is therefore biased toward deterministic structure and legibility instead of free-form visual manipulation.

The decisive architectural move in this generation is the fixed six-slot board. Earlier spatial behavior allowed flexible placement, but it also made overlap, clipping, and inconsistent reading order part of normal operation. The current board turns that open-ended canvas into a bounded surface with stable slots, fixed two-column rhythm, and predictable overflow through vertical scrolling. The visual layer now supports two moods on the same structure: `bhadralok` as the parchment-forward gothic treatment and `vanilla` as the calmer monochrome editorial baseline. Campaign titles remain emphasized through weight and spacing, while project rows remain the execution-first surface in both aesthetics.

Persistence remains sync-first for the map itself. Core state is written to `chrome.storage.sync` when extension APIs are available, with local fallback when running outside full extension context. The extension also pins a stable public key in `manifest.json` so unpacked installs resolve to one extension ID and therefore one sync namespace across devices. Aesthetic choice follows the same sync-first philosophy through its own preference key, but transfer payloads stay deliberately data-only so export/import remains schema-stable and focused on campaigns/projects. The codebase also keeps separate scaffold modules for future device-preference and cloud-sync evolution without exposing those controls as first-class sidebar actions today.

# Ontology

The primary entity is the campaign. A campaign is a strategic container with identity, title, compatibility color, and a single active mission field. In board mode, campaigns are treated as ordered records rather than positioned objects: legacy coordinate fields still exist in state for compatibility, but rendering no longer depends on x/y geometry. Mission intent is represented only by `currentMission`, which keeps the campaign model focused on present direction rather than built-in history.

The second core entity is the project. A project is either launchable or physical. Launchable projects hold a link and link type metadata so the system can normalize web and URI patterns; that normalization now also strips the volatile `pg` query parameter from Google Play Books reader URLs so reading progress resumes from Google's own "last page" memory instead of a hard-coded page anchor. Physical projects intentionally carry no launch link so real-world artifacts can live in the same map model without fake URLs. Projects can belong to multiple campaigns, which means a single project record can appear in more than one campaign card as a deliberate duplicate view.

A third entity is the board state snapshot itself. The state object is versioned and timestamped, with campaigns and projects as collections plus `updatedAt` for sync conflict avoidance in the UI subscription path. Around that state, transfer uses a versioned envelope with `format`, `version`, and `exportedAt` so import validation can fail safely before any mutation happens.

There is also a lightweight scaffolding layer for future concerns. `src/devicePrefs.js` preserves a per-device storage boundary, and `src/googleSync.js` preserves cloud-sync status and diagnostics contracts. In the current product surface these remain infrastructural extension points rather than active operator entities, but they keep boundaries clear for future capability growth.

# Geography

At the root, `manifest.json` defines extension identity, permissions, and the new-tab override. The manifest display name is intentionally `Return by Shomo` so Chrome's bottom attribution link uses that exact label, while the in-page product identity remains `Return`. The pinned `key` is a structural artifact, not a cosmetic one: changing it creates a different extension ID and therefore a different `chrome.storage.sync` namespace. `newtab.html` is the single shell document. It defines the collapsible sidebar, primary creation actions, the aesthetic toggle action, transfer actions, board mount point, panel mount point, and hidden import file input that keeps JSON import native without persistent UI clutter.

The main stylesheet for the bhadralok mood lives in `styles/newtab.css`, while `styles/newtab-vanilla.css` preserves the vanilla mood. Both files are complete theme surfaces rather than partial overrides, so runtime switching is one explicit link swap instead of a patchwork of class toggles. Custom type assets live in `styles/fonts/`. Across both themes, token discipline keeps text darker than working surfaces and preserves the fixed board geometry and interaction model.

Application logic lives under `src/`. `src/model.js` is the domain core: it normalizes incoming payloads, enforces campaign/project invariants, and applies pure mutations for campaign/project/mission lifecycle operations. `src/layout.js` shapes normalized state into six render slots and campaign-to-project groupings for deterministic board rendering. `src/storage.js` handles map persistence and storage subscriptions. `src/transfer.js` owns export envelope generation, serialization, filename strategy, and strict import parsing. `src/aestheticPrefs.js` owns the synced mood preference channel and sanitization rules. `src/main.js` is the integration runtime that wires DOM events, panel workflows, aesthetic application, render cycles, and persistence scheduling.

Two additional modules remain deliberately separated even in their scaffold phase. `src/devicePrefs.js` defines the local-only preference boundary so machine-specific behavior can be reintroduced without polluting shared state contracts. `src/googleSync.js` defines availability, status, and diagnostics interfaces for future Google-backed sync flows. Product-facing documentation is held in `README.md`, while `docs/V1_SPEC.md` and `docs/VISION.md` capture implementation scope and longer-horizon direction.

# Flow

When a new tab opens, `newtab.html` loads `src/main.js`. Initialization reads shared map state, local device scaffolding, and synced aesthetic preference in parallel, normalizes state through `src/model.js`, sets the sidebar to collapsed by default, applies the active aesthetic by swapping the stylesheet link, binds global interactions, and renders immediately without waiting for manual input. After boot, storage subscriptions keep multiple extension surfaces aligned; incoming remote state is normalized and applied only when its timestamp differs from the current in-memory state, and incoming aesthetic preference changes are applied live in the same way.

Rendering is deterministic. `src/layout.js` always returns exactly six slots, so the board shape is stable at every campaign count. Occupied slots render campaign cards; empty slots render explicit create affordances. Project grouping is membership-driven, so multi-campaign projects intentionally appear in each relevant card. In the current presentation, projects are visually framed as a card-level folio with single-column rows, a deliberately bolder project-name weight, a very light contrast shadow, and gentle motion accents so execution items surface first without relying on conspicuous size jumps or decorative effects. Sidebar summary text is compact (`c`, `p`, `m`) for low visual load while still exposing full accessible labels.

Editing uses two channels based on complexity. Campaign names and current mission text are inline editable, with mission updates committing on blur and clearing handled by emptying that same field. Project creation and editing run through the panel workflow because mode, link semantics, and multi-campaign membership require structured controls. During save, link normalization runs before persistence, which includes automatic cleanup of Google Play Books reader links by removing any explicit page anchor so future launches defer to the platform's latest-reading-position redirect.

Launching behavior is mode-aware. Launchable projects open their links, while physical projects show a local explanatory tooltip instead of attempting navigation. Right-click on a project remains a direct edit shortcut for fast operator flow. Campaign deletion cascades membership cleanup, and orphaned projects are removed by domain rule.

Transfer is explicit and defensive. Export builds a versioned JSON envelope and triggers a downloadable snapshot. Import reads file text, validates format/version/timestamp/shape, normalizes incoming state, and requires a replace-all confirmation that compares current and incoming entity counts before applying mutations. Aesthetic selection and other UI preferences are intentionally left out of export payloads, so transfers move map intent without coupling personal presentation mood.

# Philosophy

The architecture chooses bounded clarity over maximal freedom. The six-slot board is a deliberate constraint that trades infinite-canvas expressiveness for predictable scanning, simpler interaction logic, and lower maintenance risk. This is not only a UI decision; it is a system contract that simplifies normalization, rendering, and cross-device consistency.

Separation of concerns is maintained as a practical engineering tool. Domain truth lives in `src/model.js`, view shaping in `src/layout.js`, integration wiring in `src/main.js`, map persistence boundaries in `src/storage.js`, aesthetic preference boundaries in `src/aestheticPrefs.js`, and transfer contracts in `src/transfer.js`. That decomposition lets visual redesigns move quickly without destabilizing mutation rules, and lets storage or sync strategy evolve without rewriting board behavior.

Recent evolution also reflects intentional subtraction. The active sidebar now focuses on creation and transfer essentials, while per-device routing and Google cloud-sync features remain as modular scaffolds rather than exposed controls. This keeps the current operator surface tight while preserving clear seams for future capability expansion. The result is a system that is constrained on purpose, comprehensible under load, and easier to evolve without accidental coupling.
